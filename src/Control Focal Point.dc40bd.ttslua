-- Credit for the logic and layout of replenishing resources goes to Steam user K7_Avenger.

function onSave()    --We make a table of data we want to save. WE CAN ONLY SAVE 1 TABLE.
    local data_to_save = {currentStep=currentStep}    --We use this command to convert the table into a string
    saved_data = JSON.encode(data_to_save)    --And this inserts the string into the save information for this script.
    return saved_data    --Data is now saved.
end

function onload(saved_data)
    deck = getObjectFromGUID("65b2c8")
    coalSupply = getObjectFromGUID('cce2d0')
    oilSupply = getObjectFromGUID('39d679')
    garbageSupply = getObjectFromGUID('02b728')
    uraniumSupply = getObjectFromGUID('b1a8fd')

    marketZones = {
        getObjectFromGUID("8520f3"),
        getObjectFromGUID("032a82"),
        getObjectFromGUID("16b504"),
        getObjectFromGUID("9d7327"),
        getObjectFromGUID("cd9b34"),
        getObjectFromGUID("1c3d82"),
        getObjectFromGUID("9d12fd"),
        getObjectFromGUID("8c1819")
    }

    currentStepTextBox = getObjectFromGUID("67e541")

    step3Guid = "e36b67"
    pp13Guid = "9f3848"
    startingPowerPlantGuids = {"4f9859", "0e9631", "fc6c5f", "eea3b2", "c4995b", "7ab381", "c5d33f", "2dcb73"}

    loadPowerPlantInfo()
    initCurrentStep(saved_data)

    self.createButton({label="Start", click_function="startGame", function_owner=self, position={0.0, 0.5, 0.0}, rotation={0, 180, 0}, height=600, width=1400, font_size=280})
    --[[
    currentStepTextBox = spawnObject({type="3DText", sound=false, rotation={x=90, y=90, z=0}, position={x=18, y=1, z=0}})
    currentStepTextBox.setColorTint("White")
    currentStepTextBox.TextTool.setValue("Step 1")
    ]]
end

function initCurrentStep(saved_data)
    if saved_data ~= "" then --First we check if there was information saved in this script yet
        local loaded_data = JSON.decode(saved_data) --If there is save data, first we convert the string back to a table
        currentStep = loaded_data.currentStep --Then we pull out data out of the table
    else
        currentStep = 1 -- Default value if no save data
    end
end

function performBureaucracy()
    adjustMarketHighest()
    replenishResources()
end

function loadPowerPlantInfo()
    deckContents = {}
    -- Need to track all power plants separately for lookup by GUID since the
    -- Number attribute is not available when loaded from Zone.getObjects()
    allPowerPlants = {}
    for _, card in pairs(JSON.decode(deck.getJSON()).ContainedObjects) do
        deckContents[card.GUID] = card
        allPowerPlants[card.GUID] = card
    end
end

function startGame()
    step3DeckList = {}

    for index, ppGuid in pairs(startingPowerPlantGuids) do
        deck.takeObject({
            position = marketZones[index].getPosition(),
            flip = true,
            guid = ppGuid
        })
    end

    removePowerPlants()

    for _, button in pairs(self.getButtons()) do
        if button.label == "Start" then
            self.removeButton(button.index)
            break
        end
    end

    self.createButton({label="New Plant", click_function="drawPowerPlant", function_owner=self, position={2.0, 0.5, 0.0}, rotation={0, 180, 0}, height=600, width=1400, font_size=280})
    self.createButton({label="End Round", click_function="performBureaucracy", function_owner=self, position={-2.0, 0.1, 0.0}, rotation={0, 180, 0}, height=600, width=1400, font_size=280})
    setCurrentStep(currentStep)
end

function removePowerPlants()
    local toRemove = nil
    if #getSeatedPlayers() < 4 then
        toRemove = 8
    elseif #getSeatedPlayers() == 4 then
        toRemove = 4
    else
        toRemove = 0
    end

    for k = 1, toRemove do
        -- The index accepted by Object.takeObject is 0-indexed.
        local deckIndex = nil
        repeat
            deckIndex = math.random(1, #deck.getObjects() - 1)
        until deck.getObjects()[deckIndex + 1].guid != step3Guid

        local obj = deck.takeObject({
            index = deckIndex
        })
        obj.destruct()
    end
end


function adjustMarketHighest()
    local ppMarket = getPowerPlantMarket()
    local highestPlant = table.remove(ppMarket, 8)
    deck.putObject(highestPlant)

    step3DeckList[highestPlant.guid] = true

    addNewPlantToMarket(ppMarket)
end

function adjustMarketLowest()
    local ppMarket = getPowerPlantMarket()
    local lowestPlant = table.remove(ppMarket, 1)
    lowestPlant.destruct()

    addNewPlantToMarket(ppMarket)
end

function drawPowerPlant()
    local ppMarket = getPowerPlantMarket()
    if #ppMarket < 8 then
        addNewPlantToMarket(ppMarket)
    end
end

function deckTopGuid()
    for _, card in ipairs(deck.getObjects()) do
        guid = card.guid
        if not step3DeckList[guid] and (guid != step3Guid or #deck.getObjects() <= len(step3DeckList) + 1) then
            return guid
        end
    end
end

function addNewPlantToMarket(ppMarket)
    local pp13Card = deckContents[pp13Guid]
    local nextCard = nil
    local nextCardGuid = nil
    if pp13Card then
        nextCard = pp13Card
    else
        nextCardGuid = deckTopGuid()
        nextCard = deckContents[nextCardGuid]
    end

    if nextCardGuid == step3Guid then
        setCurrentStep(3)
    end

    -- Insert the new power plant into the market
    for index = #ppMarket, 1, -1 do
        local cardObj = ppMarket[index]
        local card = allPowerPlants[cardObj.guid]
        if card.Number > nextCard.Number then
            ppMarket[index + 1] = card
        else
            ppMarket[index + 1] = nextCard
            break
        end
    end

    -- Move the power plant cards based on the new list above, and draw the new card to its appropriate place.
    for index, card in ipairs(ppMarket) do
        if card == nextCard then
            deck.takeObject({
                position = marketZones[index].getPosition(),
                flip = true,
                guid = card.GUID
            })
            deckContents[card.GUID] = nil
        else
            card.setPositionSmooth(marketZones[index].getPosition(), false, false)
        end
    end
end

function getPowerPlantMarket()
    local ppMarket = {}
    for _, marketZone in ipairs(marketZones) do
        for _, obj in ipairs(marketZone.getObjects()) do
            if obj.tag == "Card" then
                table.insert(ppMarket, obj)
            end
        end
    end
    return ppMarket
end

function setCurrentStep(step)
    currentStep = step
    -- currentStepTextBox.setValue("Step " .. tostring(currentStep))
    currentStepTextBox.TextTool.setValue("Step " .. tostring(currentStep))
end

function replenishResources()
    zone = getObjectFromGUID('778d7a')
    zoneObjects = zone.getObjects()
    coalCount = countFromName(zoneObjects,"Coal")
    oilCount = countFromName(zoneObjects,"Oil")
    garbageCount = countFromName(zoneObjects,"Garbage")
    uraniumCount = countFromName(zoneObjects,"Uranium")

    playerCount = #getSeatedPlayers()
    players = playerCount - 1

    -- Table of resources to add == resourceTable[#getSeatedPlayers[currentStep]]
    coalTable = {{3,4,3},{4,5,3},{5,6,4},{5,7,5},{7,9,6}}
    oilTable = {{2,2,4},{2,3,4},{3,4,5},{4,5,6},{5,6,7}}
    garbageTable = {{1,2,3},{1,2,3},{2,3,4},{3,3,5},{3,5,6}}
    uraniumTable = {{1,1,1},{1,1,1},{1,2,2},{2,3,2},{2,3,3}}

    --Add the coal to the market
    coalAdding = coalTable[players][currentStep]
    if #coalSupply.getObjects() < coalAdding then coalAdding = #coalSupply.getObjects() end
    coalZCoords = {12.75, 11.61, 10.41, 8.91, 7.77, 6.57, 5.08, 3.95, 2.74, 1.38, 0.24, -0.96, -2.45, -3.59, -4.79, -6.20, -7.33, -8.54, -9.98, -11.12, -12.32, -13.87, -15.00, -16.20}
    for i = 1, coalAdding do
        local params = {}
        xPos = 13.08
        yPos = 1.78
        zPos = coalZCoords[coalCount + i]
        params.position = {xPos, yPos, zPos}
        coalSupply.takeObject(params)
    end

    --Add the oil to the market
    oilAdding = oilTable[players][currentStep]
    if #oilSupply.getObjects() < oilAdding then oilAdding = #oilSupply.getObjects() end
    oilZCoords = {11.95, 11.12, 10.29, 8.16, 7.33, 6.49, 4.39, 3.54, 2.69, 0.58, -0.25, -1.11, -3.21, -4.06, -4.90, -7.02, -7.82, -8.68, -10.79, -11.65, -12.48, -14.60, -15.43, -16.26}
    for i = 1, oilAdding do
        local params = {}
        xPos = 14.03
        yPos = 0.97
        zPos = oilZCoords[oilCount + i]
        params.position = {xPos, yPos, zPos}
        oilSupply.takeObject(params)
    end

    --Add the garbage to the market
    garbageAdding = garbageTable[players][currentStep]
    if #garbageSupply.getObjects() < garbageAdding then garbageAdding = #garbageSupply.getObjects() end
    garbageZCoords = {12.70, 11.53, 10.41, 8.92, 7.78, 6.61, 5.10, 3.98, 2.83, 1.30, 0.13, -1.00, -2.46, -3.61, -4.80, -6.27, -7.41, -8.53, -10.04, -11.19, -12.32, -13.84, -14.96, -16.16}
    for i = 1, garbageAdding do
        local params = {}
        xPos = 15.04
        yPos = 1.03
        zPos = garbageZCoords[garbageCount + i]
        params.position = {xPos, yPos, zPos}
        garbageSupply.takeObject(params)
    end

    --Add the uranium to the market
    uraniumAdding = uraniumTable[players][currentStep]
    if #uraniumSupply.getObjects() < uraniumAdding then uraniumAdding = #uraniumSupply.getObjects() end
    uraniumXCoords = {14.95, 14.95, 13.28, 13.28, 14.03, 14.03, 14.03, 14.03, 14.03, 14.03, 14.03, 14.03}
    uraniumZCoords = {15.75, 14.21, 15.75, 14.21, 12.81, 9.01, 5.23, 1.44, -2.36, -6.17, -9.94, -13.73}
    for i = 1, uraniumAdding do
        local params = {}
        xPos = uraniumXCoords[uraniumCount + i]
        yPos = 0.96
        zPos = uraniumZCoords[uraniumCount + i]
        params.position = {xPos, yPos, zPos}
        uraniumSupply.takeObject(params)
    end

end

function countFromName(zoneObjects, string)
    count = 0
    for _, object in ipairs(zoneObjects) do
        if object.getName() == string then
            count = count + 1
        end
    end
    return(count)
end

function len(obj)
    if type(obj) == "string" then
        return string.len(obj)
    elseif type(obj) == "table" then
        count = 0
        for _, _ in pairs(obj) do
            count = count + 1
        end
        return count
    end
end